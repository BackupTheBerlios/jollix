<!DOCTYPE public "-//w3c//dtd html 4.01 transitional//en"
		"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
	<title>Jollix</title>
	<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
	<meta name="GENERATOR" content="Quanta Plus">
	<link rel=stylesheet type="text/css" href="../common/stylesInstall.css">
</head>

<body link="#4379A0" alink="#62B1EA" vlink="#4D989D">
<div id="text">
	<table bgcolor="#f2f2f2" border="0" width="100%">
		<tr>
			<td width="263" valign="top" align="right">
				<a href="de_home.html"><img src="../img/jollix-logo-128pt-blue2.jpg" alt="jollix" border="0"></a>
			</td>
			<td width="20"></td>
			<td id="btext" valign="top" align="left">Eine GNU/Linux Distribution basierend auf Gentoo Linux<br>A GNU/Linux distribution based on Gentoo Linux<br><br>
				<table border="0" width="100%">
					<tr>
						<td align="left"><a href="de_news.html"><img src="../img/news.jpg" border=0></a></td>
						<td align="left"><a href="de_docu.html"><img src="../img/dokumentation.jpg" border=0></a></td>
						<td align="left"><a href="de_download.html"><img src="../img/download.jpg" border=0></a></td>
						<td align="left"><a href="de_features.html"><img src="../img/features.jpg" border=0></a></td>
					</tr>
					<tr>
						<td align="right"></td>
						<td align="right"><a href="de_screenshots.html"><img src="../img/screenshots.jpg" border=0></a></td>
						<td align="right"><a href="http://jollix.berlios.de/phpBB2/index.php"><img src="../img/forum.jpg" border=0></a></td>
						<td align="right"><a href="de_about.html"><img src="../img/about.jpg" border=0></a></td>
	  			</tr>
				</table>
			</td>
			<td width="20"></td>
			<td width="100" valign="center" align="center"><h4>DOCU</h4><br>
				<a href="../en/en_home.html"><img src="../img/english.gif" border="0"><br>English Version</a>
			</td>
			<td width="20"></td>
		</tr>
	</table>
	<hr>
	<table>
	<tr>
		<td valign="top">
			<a href="#faq">FAQ</a><br>
			<a href="#ausprobieren">Jollix ausprobieren <b>ohne</b> Installation</a><br>
			<a href="#installation">Jollix installieren</a><br>
			<hr>	
				<a name="faq"></a>
				<h3><b><u>FAQ</u></b></h3>
				<h4>Was ist jollix?</h4>
				<a href="de_about.html#about">Hier</a> klicken.
				<a name="gentoo"></a><h4>Was ist Gentoo?</h4>
				Gentoo Linux ist eine vielseitige und schnelle, komplett freie Linux Distribution,
				die für Linux Power-User gedacht ist. Im Gegensatz zu anderen Distributionen
				hat Gentoo Linux ein fortschrittliches Paketverwaltungs-System namens Portage.
				Portage ist ein Ports-System in der Tradition von <a href="http://www.openbsd.org/de/ports.html" target="_blank">BSD-Ports</a>.
				Es ist in Python realisiert und bringt einige zusätzliche Features mit,
				darunter auch ein fein granuliertes Management von Abhängigkeiten,
				die Möglichkeit, "fake"-Installationen durchzuführen,
				ein Pfad-Sandboxing, sicheres "Unmerging", System-Profile,
				virtuelle Pakete und ein Konfigurationsdatei-Management.<br>
				Gentoo Linux bildet die Basis von jollix und ist auf <a href="http://www.gentoo.org" target="_blank">www.gentoo.org</a>
				sehr gut dokumentiert.<br>
				<h4>Kann ich jollix gefahrlos nur mal eben ausprobieren?</h4>
				Ja. Jollix kann "nur-lesend" direkt von CD-ROM gestartet werden.
				Dabei wird das bestehende System nicht verändert.
				<a name="wine"></a><h4>Was ist wine?</h4>
				<a href="http://www.winehq.com/" target="_blank">Wine</a> ist eine Implementierung
				der Windows Win32 und Win16 APIs auf Basis des Fenstermanagers X und Unix. Wine
				stellt unter Linux eine Umgebung zur Verfügung, in der Windows-Programme (.exe Dateien)
				auch unter Linux laufen. Wine benötigt keine Installation von Windows, da es eine hundertprozentige
				Unabhängigkeit vom Microsoft Code hat. Optional kann es die System DLL`s zur
				besseren Unterstützung der Windowsprogramme nutzen. Wine kommt mit dem Quellcode,
				mit Dokumentationen, Beispielen und es ist frei einsetzbar.<br>
				Nicht alle Windows-Programme, insbesondere neuere, sind
				jedoch auch garantiert lauffähig. So sind nicht alle Funktionen der neuesten Windows
				Versionen nachgebildet, die von einigen Programme zwingend benötigt werden.
				In jollix ist wine so eingerichtet, dass die Spiele und Programme, die in
				der jollix-wine-liste stehen, garantiert laufen.
				Eine deutschsprachige Seite über wine ist
				<a href="http://www.linux-wine.de/" target="_blank">www.linux-wine.de</a>, die Original Seiten
				sind auf <a href="http://www.winehq.com/" target="_blank">www.winehq.com</a> zu finden.<br>
				<a name="kde"></a><h4>Was ist KDE?</h4>
				KDE ist eine moderne grafische Arbeitsumgebung für UNIX Workstations.
				KDE strebt an, den Bedarf für eine einfach zu bedienende Arbeitsfläche
				für UNIX Workstations zu decken, ähnlich den Arbeitsumgebungen,
				die man unter MacOS oder Windows 9x/NT/2000/XP vorfindet.
				Alles Wissenswerte zu KDE gibt es auf <a href="http://www.kde.de" target="_blank">
				www.kde.de</a> nachzulesen.<br><br>
				<hr>
				<a name="ausprobieren"></a>
				<h3><b><u>Jollix Ausprobieren <b><u>ohne</u></b> Installation</u></b></h3>
				Die LiveCD wird einfach ins CD-Rom oder DVD-Laufwerk des Rechners eingelegt.
				Im BIOS muss als erstes boot device "CDROM" o.ä. ausgewählt sein. Dann
				fährt jollix von der CD hoch und der Benutzer "user" wird automatisch angemeldet.
				<hr>
				<a name="installation"></a>
				<h3><b><u>Installation</u></b></h3>
				<p class="chaphead">ACHTUNG! DIE FOLGENDE ANLEITUNG IST NUR F&Uuml;R LEUTE GEDACHT, DIE BEREITS ERFAHRUNG IM UMGANG MIT LINUX HABEN, BEREITS EINE ANDERE LINUX DISTRIBUTION INSTALLIERT HABEN, DAHER GRUNDKENNTNISSE HABEN UND NICHT VOLLKOMMEN NEU IN LINUX EINSTEIGEN. F&Uuml;R ALLE UMSTEIGER IST JOLLIX IN DER VERSION 0.3 ALS LIVECD ZUM TESTEN UND KENNENLERNEN VON LINUX GEDACHT. EIN GRAFISCHES INSTALLATIONSPROGRAMM ZUR EINFACHEN INSTALLATION VON JOLLIX KOMMT SP&Auml;TER!</p>
				<p class="dochead">jollix Linux Installationsanleitung</p>
				<p class="chaphead">Wichtige Anmerkungen:</p>
				<p>Die Installation von jollix auf der Festplatte erfolgt auf eigene Gefahr!
					Die folgende Anleitung bezieht sich auf die jollix Version <b>0.3 Beta</b> und
					ist <b>nur</b> eine Anleitung, ein grafischer Installer wird es in einer der
					n&auml;chsten jollix Versionen geben.
				</p>
				<p>Jollix kann mit dieser Anleitung nur auf einer v&ouml;llig unbenutzten Festplatte
					installiert werden bzw. auf einer vorbereiteten Festplatte, die noch Platz f&uuml;r
					weitere Partitionen bietet. Befindet sich bereits ein anderes Betriebssystem auf der
					Festplatte und wird von diesem die gesamte Festplatte belegt, so bleibt nur eine
					Neupartitionierung oder eine Verkleinerung dieser Partition. Sowohl eine Neupartitionierung
					als auch eine Verkleinerung einer Partition sollte bedacht und vorsichtig durchgef&uuml;hrt
					werden! Eine Verkleinerung der bestehenden Partition ist unter jollix 0.3 mit QtParted m&ouml;glich, jedoch sollte man hierbei sehr vorsichtig vorgehen und es empfiehlt sich vorher mit partimage, das auch auf der jollix 0.3 LiveCD enthalten ist bzw. einem anderen Backup Programm, die bestehende Partition komplett zu sichern und die Backupdatei auf einem anderen Speichermedium, z.B. einer 2. Festplatte oder einer CDR/DVDR, zu sichern! Das jollix Team übernimmt keine Haftung bei Datenverlust und weist ausdrücklich auf die Gefahr des Datenverlustes bei einer Verkleinerung einer bestehenden Partition hin.
					Die Installation parallel zu einem bestehenden System ist kein Problem, sofern es
					m&ouml;glich ist, neue Partitionen anlegen zu k&ouml;nnen. Auch in diesem Fall ist es sehr ratsam,
					ein komplettes Backup des bestehenden Systems zu machen und dieses separat, z.B. auf einer
					CD zu sichern bzw. alle wichtigen Daten des Systems extern zu sichern. Die Anleitung
					erl&auml;utert auch die Installation und Konfiguration eines Bootmanagers, der es
					erm&ouml;glicht beide Betriebsysteme aus einem Bootmen&uuml; heraus getrennt zu booten.
				</p>
				<p>Das Team von jollix &uuml;bernimmt keine Verantwortung f&uuml;r Sch&auml;den
					am Rechner und/oder den Verlust von Daten durch die Installation von jollix. Die Installation
					geschieht vollkommen auf eigene Gefahr!
				</p>
				<p class="chaphead"><span class="chapnum">0.</span>&Uuml;berblick</p>
				<ul>
					<li><a href="#chap1">1. Vorbereitungen</a></li>
					<li><a href="#chap2">2. Festplatte partitionieren</a></li>
					<li><a href="#chap3">3. Dateisysteme anlegen</a></li>
					<li><a href="#chap4">4. jollix auf der Festplatte installieren</a></li>
					<li><a href="#chap5">5. Abschliessende Konfiguration der jollix Festplatteninstallation</a></li>
					<li><a href="#chap6">6. Installation beenden und Rechner neu starten</a></li>
					<li><a href="#chap7">7. Einstellungen nach der Installation</a></li>
				</ul>
				<a name="chap1"><p class="chaphead"><span class="chapnum">1.</span>Vorbereitungen</p></a>
				<p>Alle nun folgenden Installationsschritte m&uuml;ssen als Superuser (root) in
					einer Konsole des gebooteten jollix Systems durchgef&uuml;hrt werden. Hierzu &ouml;ffnet
					man ein Konsolenfenster und meldet sich als Superuser mit dem Befehl
					<span class="shell">su -</span> an [1.1].
				</p>
				<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
					<tr><td class="infohead" bgcolor="#eec625"><p>
						1.1: Als Superuser root in einem Konsolenfenster anmelden, Befehl:
						<span class="shell">su -</span></p></td>
					</tr>
					<tr><td bgcolor="#000000"><pre>
<span class="greentext">user@jollix</span><span class="bluetext"> user # </span><span class="whitetext">su -</span>
</pre></td></tr>
</table>
<p>Wie im n&auml;chsten Konsolenausschnitt zu sehen ist [1.2], sollte sich jetzt der Prompt ge&auml;ndert haben [<span class="redtext">jollix</span><span class="bluetext"> root # </span>], so dass man jetzt Superuser ist und mit der eigentlichen Installation beginnen kann. Wurde vor dem Beginn der Installation bereits auf die Festplatte zugegriffen (Desktop Ordner "devices"), auf die nun jollix installiert werden soll,  so m&uuml;ssen die eingebundenen Partitionen jetzt wieder unmountet werden, so das kein Zugriff mehr besteht [1.2]:</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
1.2: Bereits eingebundene Festplatten Partitionen wieder unmounten, Befehl: umount</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> root # </span><span class="whitetext">umount /mnt/hd*</span>
</pre></td></tr>
</table>
<p>Anschliessend kann man pr&uuml;fen, dass wirklich keine Festplatten Partitionen mehr eingebunden sind [1.3]:</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
1.3: Aktuell noch eingebundene Dateisysteme anzeigen, Befehl: mount</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mount</span>
</pre></td></tr>
</table>
<p>Die Ausgabe von [1.3] sollte wie folgt aussehen, es sollten am Ende der Ausgabe keine Eintr&auml;ge mehr sein, die <span class="path">/mnt/hdxx</span> enthalten (z.B. /mnt/hda1). 
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von mount:</b></p>
<pre>proc on /proc type proc (rw)
none on /dev type devfs (rw)
tmpfs on /var/lib/init.d type tmpfs (rw,mode=0644,size=2048k)
tmpfs on /dev/shm type tmpfs (rw)
none on /proc/bus/usb type usbfs (rw)
/dev/cdroms/cdrom0 on /mnt/cdrom type iso9660 (ro)
/mnt/cdrom/livecd.cloop on /mnt/cloop type ext2 (ro)
tmpfs on / type tmpfs (rw)
</pre>
</td></tr></table>
<p>Alle sp&auml;teren Installationsschritte werden im Verzeichnis <span class="path">/mnt</span> durchgef&uuml;hrt [1.4]. Das Einstellen von Datum und Uhrzeit erfolgt in Schritt [1.5].</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
1.4: In das Verzeichnis /mnt wechseln, Befehl: cd</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> root # </span><span class="whitetext">cd /mnt</span>
</pre></td></tr>
</table>
<p>Der Befehl <span class="shell">date</span> zeigt die augenblicklich vom System eingestellte Uhrzeit inkl. Datum an. Das Einstellen von Uhrzeit und Datum erfolgt in folgendem Format: Monat(06)Tag(02)Uhrzeit(1737)Jahr(2003), d.h. f&uuml;r den 02. Juni 2003, 17:37 Uhr ist 060217372003 einzugeben. Der folgende Konsolenausschnitt zeigt das Beispiel [1.5]:</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
1.5: Datum und Uhrzeit richtig einstellen, Befehl: date</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">date 060217372003</span>
</pre></td></tr>
</table>
<a name="chap2"><p class="chaphead"><span class="chapnum">2.</span>Festplatte partitionieren</p></a>
<p>ACHTUNG: Wie bereits in der Einleitung angek&uuml;ndigt, &uuml;bernimmt das Team von jollix keine Verantwortung f&uuml;r Sch&auml;den und/oder Datenverlust durch das Partitionieren der Festplatte! Durch fehlerhafte Partitionierung der Festplatte k&ouml;nnen alle darauf enthaltenen Daten verloren gehen. Die Partitionierung geschieht vollkommen auf eigene Gefahr!</p>
<p>Im Folgenden soll kurz erl&auml;utert werden, was unter Partitionieren der Festplatte zu verstehen ist, in der f&uuml;r Linux typischen Benennung von Festplatten und Laufwerken und zwei m&ouml;gliche Partitionierungsm&ouml;glichkeiten aufgezeigt werden.</p>
<p>Unter Partitionierung versteht man das Aufteilen der Festplatte in verschiedene Bereiche, die einzeln formatiert werden k&ouml;nnen. So entstehen durch Partitionierung einer 40GB Festplatte in 4 gleich grosse Teile 4 neue Festplatten zu 10GB. Die Partitionierung der Festplatte kann jederzeit wieder r&uuml;ckg&auml;ngig gemacht werden. Befindet sich eine Festplatte im Rechner, so wird diese in Linux als /dev/hda angesprochen, sofern sie als Master am ersten IDE Kanal angeschlossen ist. Eine zweite am ersten IDE Kanal als Slave angeschlossene Platte w&uuml;rde demnach als /dev/hdb, die Master Platte am zweiten IDE Kanal als /dev/hdc und wiederum die Slave Platte als /dev/hdd bezeichnet werden. In den meisten F&auml;llen werden am zweiten IDE Kanal CD/CD-RW/DVD -Laufwerke angeschlossen sein, diese werden dann ebenso bezeichnet mit hdc bzw. hdd. Die m&ouml;glichen Partitionen einer Festplatte werden von 1 an hochgezählt. Befinden sich auf hda insgesammt 3 Partitionen, so werden diese mit hda1, hda2 und hda3 bezeichnet. In den nun folgenden zwei Beispielen wird davon ausgegangen, dass sich erstens &uuml;berhaupt keine Partitionen auf der Festplatte befinden, diese also unpartitioniert ist, bzw. dass die darauf vorhandenen Partitionen gel&ouml;scht werden k&ouml;nnen. Das zweite Beispiel geht davon aus, dass sich auf der Platte ein anderes Betriebssystem in der 1. Partition befindet, der Rest der Festplatte aber unpartitioniert ist. F&uuml;r den Fall, dass eine einzige Partition, die gesamte Festplatte belegt, bleibt nur eine komplette Neupartitionierung bzw. eine Verkleinerung dieser Partition (auf die Gefahren wurde in der Einleitung bereits hingewiesen). Wichtig: Wird die Partition gelöscht, gehen dabei alle Daten auf der Festplatte verloren!</p>
<p>Beim Partitionieren unterscheidet man prim&auml;re und erweiterte Partitionen. Maximal k&ouml;nnen 4 prim&auml;re Partitionen angelegt werden (hda1 bis hda4). Sollen/M&uuml;ssen mehr als 4 Partitionen angelegt werden, muss sp&auml;testens die 4. Partition eine erweiterte Partition werden, in welcher dann wiederum logische Partitionen angelegt werden k&ouml;nnen.</p>

<p>1. Beispiel: Im Rechner befindet sich eine vollkommen unbenutzte Festplatte, die komplett f&uuml;r jollix genutzt werden kann und keine weiteren Partitionen enth&auml;lt bzw. vorhandene gel&ouml;scht werden k&ouml;nnen. Eine minimale und sinnvolle Partitionierung besteht aus 3 Partitionen, n&auml;mlich aus einer boot- (hda1), einer swap- (hda2) und einer root-Partition (hda3):</p>

<table class="ntable">
	<tr>
	<td bgcolor="#dbdbdb" class="infohead"><b>Partition</b></td>
	<td bgcolor="#dbdbdb" class="infohead"><b>Gr&ouml;sse (empfohlen)</b></td>
	<td bgcolor="#dbdbdb" class="infohead"><b>Dateisystem (empfohlen)</b></td>
	<td bgcolor="#dbdbdb" class="infohead"><b>Device Bezeichnung</b></td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">boot Partition mit Kernel und Bootkonfiguration</td>
	<td bgcolor="#dbdbdb" class="tableinfo">32 MB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">ext2</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda1</td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">swap Partition</td>
	<td bgcolor="#dbdbdb" class="tableinfo">512 MB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">Linux swap</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda2</td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">root Partition mit dem jollix System</td>
	<td bgcolor="#dbdbdb" class="tableinfo">&gt;=4 GB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">ext3</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda3</td>
	</tr>
</table>

<p>2. Beispiel: Auf der 1. Partition der Festplatte befindet sich ein fremdes Betriebssystem, die Festplatte enth&auml;lt jedoch noch freien Platz zum Anlegen der notwendigen jollix Partitionen. Die Nummerierung der Partitionen verschiebt sich daher um eins nach hinten, boot- (hda2), swap- (hda3) und root-Partition (hda4):</p>

<table class="ntable">
	<tr>
	<td bgcolor="#dbdbdb" class="infohead"><b>Partition</b></td>
	<td bgcolor="#dbdbdb" class="infohead"><b>Gr&ouml;sse (empfohlen)</b></td>
	<td bgcolor="#dbdbdb" class="infohead"><b>Dateisystem (empfohlen)</b></td>
	<td bgcolor="#dbdbdb" class="infohead"><b>Device Bezeichnung</b></td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">Anderes Betriebssystem</td>
	<td bgcolor="#dbdbdb" class="tableinfo">Zu viele GB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">FAT/NTFS</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda1</td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">boot Partition mit Kernel und Bootkonfiguration</td>
	<td bgcolor="#dbdbdb" class="tableinfo">32 MB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">ext2</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda2</td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">swap Partition</td>
	<td bgcolor="#dbdbdb" class="tableinfo">512 MB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">Linux swap</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda3</td>
	</tr>
	<tr>
	<td bgcolor="#dbdbdb" class="tableinfo">root Partition mit dem jollix System</td>
	<td bgcolor="#dbdbdb" class="tableinfo">&gt;=4 GB</td>
	<td bgcolor="#dbdbdb" class="tableinfo">ext3</td>
	<td bgcolor="#dbdbdb" class="tableinfo">/dev/hda4</td>
	</tr>
</table>

<p>Zur Paritionierung der Festplatte kann <span class="shell">fdisk</span>, <span class="shell">cfdisk</span> und (neu!) <span class="shell">QtParted</span> benutzt werden. Im Folgenden sollen kurz die Schritte beim Partitionieren mit <span class="shell">fdisk</span> gezeigt werden. <span class="shell">QtParted</span> ist ein grafisches Partitionierungsprogramm, das neu in jollix ist und daher vorsichtig zu benutzen ist!</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
2.1: Festplatte partitionieren mit fdisk</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">fdisk /dev/hda</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Hilfe von fdisk (m for help):</b></p>
<pre>Command (m for help): m
Command action
   a   toggle a bootable flag
   b   edit bsd disklabel
   c   toggle the dos compatibility flag
   d   delete a partition
   l   list known partition types
   m   print this menu
   n   add a new partition
   o   create a new empty DOS partition table
   p   print the partition table
   q   quit without saving changes
   s   create a new empty Sun disklabel
   t   change a partition's system id
   u   change display/entry units
   v   verify the partition table
   w   write table to disk and exit
   x   extra functionality (experts only)
</pre>
</td></tr></table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Beispiel f&uuml;r die Partitionierung von /dev/hda mit fdisk:</b></p>
<pre>Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 1
First cylinder (1-1027, default 1):
Using default value 1
Last cylinder or +size or +sizeM or +sizeK (1-1027, default 1027): +32MB

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 2
First cylinder (4-1027, default 4):
Using default value 4
Last cylinder or +size or +sizeM or +sizeK (4-1027, default 1027): +512MB

Command (m for help): t
Partition number (1-4): 2
Hex code (type L to list codes): 82
Changed system type of partition 2 to 82 (Linux swap)

Command (m for help): n
Command action
   e   extended
   p   primary partition (1-4)
p
Partition number (1-4): 3
First cylinder (67-1027, default 67):
Using default value 67
Last cylinder or +size or +sizeM or +sizeK (67-1027, default 1027): +2048MB

Command (m for help): p

Disk /dev/hda: 8455 MB, 8455200768 bytes
255 heads, 63 sectors/track, 1027 cylinders
Units = cylinders of 16065 * 512 = 8225280 bytes

   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1         3     24066   83  Linux
/dev/hda2             4        66    506047+  82  Linux swap
/dev/hda3            67       316   2008125   83  Linux

Command (m for help): w
The partition table has been altered!

Calling ioctl() to re-read partition table.
Syncing disks.
</pre>
</td></tr></table>

<p>Als Alternative zu <span class="shell">fdisk</span> kann auch <span class="shell">cfdisk</span> benutzt werden. <span class="shell">cfdisk</span> ist ein men&uuml;basiertes Konsolenprogramm zum Partitionieren der Festplatte. Im 1. Beispiel sieht die Partitionierung der Festplatte wie folgt aus:</p>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von fdisk (p print the partition table):</b></p>
<pre>   Device Boot    Start       End    Blocks   Id  System
/dev/hda1             1         3     24066   83  Linux
/dev/hda2             4        66    506047+  82  Linux swap
/dev/hda3            67       316   2008125   83  Linux
</pre>
</td></tr></table>

<p>Es ist sehr wichtig, sich die Device Bezeichnungen (hda1, hda2 usw.) f&uuml;r die eigene Partitionierung genau zu merken, da diese sp&auml;ter noch f&uuml;r die Konfiguration des Systems gebraucht werden!</p>

<a name="chap3"><p class="chaphead"><span class="chapnum">3.</span>Dateisysteme anlegen</p></a>

<p>Die zuvor angelegten Partitionen werden nun formatiert, d.h. Dateisysteme darauf angelegt. F&uuml;r die boot-Partition wird ext2 [3.1] und f&uuml;r die root-Partiton ext3 [3.3] empfohlen. Dies ist nur eine Empfehlung, es existieren weitere Dateisysteme, die aber hier jetzt nicht besprochen werden k&ouml;nnen. Nur soviel: Der sp&auml;ter installierte jollix Kernel unterst&uuml;tzt alle zur Zeit bekannten Linux Dateisysteme (inkl. XFS, JFS usw.). Die swap-Partition wird unter [3.2] eingerichtet. Hier ist es sehr wichtig, die richtigen Device Bezeichnungen der eben angelegten Partitionen zu benutzen, sonst droht Datenverlust!</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
3.1: Boot Partition (hda1) formatieren, Befehl: mke2fs</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mke2fs /dev/hda1</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von mke2fs:</b></p>
<pre>mke2fs 1.32 (09-Nov-2002)
Filesystem label=
OS type: Linux
Block size=1024 (log=0)
Fragment size=1024 (log=0)
6024 inodes, 24066 blocks
1203 blocks (5.00%) reserved for the super user
First data block=1
3 block groups
8192 blocks per group, 8192 fragments per group
2008 inodes per group
Superblock backups stored on blocks:
        8193
dass man
Writing inode tables: done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 33 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
</pre>
</td></tr></table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
3.2: Swap Partition (hda2) formatieren, Befehl: mkswap</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mkswap /dev/hda2</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von mkswap:</b></p>
<pre>Setting up swapspace version 1, size = 518184 kB
</pre>
</td></tr></table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
3.3: Root Partition (hda3) formatieren, Befehl: mke2fs -j</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mke2fs -j /dev/hda3</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von mke2fs -j:</b></p>
<pre>mke2fs 1.32 (09-Nov-2002)
Filesystem label=
OS type: Linux
Block size=4096 (log=2)
Fragment size=4096 (log=2)
251392 inodes, 502031 blocks
25101 blocks (5.00%) reserved for the super user
First data block=0
16 block groups
32768 blocks per group, 32768 fragments per group
15712 inodes per group
Superblock backups stored on blocks:
        32768, 98304, 163840, 229376, 294912

Writing inode tables: done
Creating journal (8192 blocks): done
Writing superblocks and filesystem accounting information: done

This filesystem will be automatically checked every 39 mounts or
180 days, whichever comes first.  Use tune2fs -c or -i to override.
</pre>
</td></tr></table>

<p>Folgender Befehl aktiviert die swap-Partiton, so dass sie auch gleich genutzt werden kann [3.4].</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
3.4: Swap Partition (hda2) aktivieren, Befehl: swapon</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">swapon /dev/hda2</span>
</pre></td></tr>
</table>

<a name="chap4"><p class="chaphead"><span class="chapnum">4.</span>jollix auf der Festplatte installieren</p></a>

<p>Die Festplatten Partitionen sind jetzt f&uuml;r die Installation von jollix vorbereitet, so dass nun das System auf der Festplatte eingerichtet werden kann, vorher m&uuml;ssen jedoch noch die neuen Partitionen eingebunden werden, damit man sie auch ansprechen kann [4.1 bis 4.4]:</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.1: jollix Installationsverzeichnis anlegen, Befehl: mkdir</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mkdir jollix</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.2: Root Partition (hda3) einbinden, Befehl: mount</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mount /dev/hda3 jollix</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.3: Boot Verzeichnis (hda1) anlegen, Befehl: mkdir</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mkdir jollix/boot</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.4: Boot Partition (hda1) einbinden, Befehl: mount</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mount /dev/hda1 jollix/boot</span>
</pre></td></tr>
</table>

<p>Wiederum kann man pr&uuml;fen, ob alles richtig eingebunden wurde [4.4]:</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.5: Eingebundene Partitionen pr&uuml;fen, Befehl: mount</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">mount</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von mount:</b></p>
<pre>proc on /proc type proc (rw)
none on /dev type devfs (rw)
tmpfs on /mnt/.init.d type tmpfs (rw,mode=0644,size=2048k)
tmpfs on /dev/shm type tmpfs (rw)
usbdevfs on /proc/bus/usb type usbdevfs (rw)
/dev/cdroms/cdrom0 on /mnt/cdrom type iso9660 (ro)
/mnt/cdrom/livecd.cloop on /mnt/cloop type ext2 (ro)
tmpfs on / type tmpfs (rw)
/dev/hdc on /mnt/transit/hdc type iso9660 (ro)
/dev/hda3 on /mnt/jollix type ext3 (rw)
/dev/hda1 on /mnt/jollix/boot type ext2 (rw)
</pre>
</td></tr></table>

<p>In den letzten beiden Zeilen der Ausgabe ist zu sehen, dass /dev/hda3 nach <span class="path">/mnt/jollix</span> und /dev/hda1 nach <span class="path">/mnt/jollix/boot</span> gemountet wurde. Sollte die eigene Ausgabe nicht mit der obigen &uuml;bereinstimmen, wurde entweder eine andere Partitionierung gew&auml;hlt oder es liegt ein Fehler vor.</p>

<p>Jollix kann nun von der CD auf die Festplatte kopiert werden [4.6 bis 4.7]:</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.6: In das jollix LiveCD Verzeichnis wechseln: cd</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> mnt # </span><span class="whitetext">cd cloop</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
4.7: jollix auf die Festplatte kopieren, Befehl: cp</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> cloop # </span><span class="whitetext">cp -dvR * /mnt/jollix/ --preserve=mode --preserve=ownership
</span>
</pre></td></tr>
</table>

<p>Der nun folgende Kopiervorgang kann einige Minuten in Anspruch nehmen. Die &uuml;ber den Bildschirm laufenden Zeilen sind vom Kopierbefehl (Parameter v f&uuml;r verbose). Bitte darauf achten, dass der Befehl richtig eingegeben wurde.</p>

<a name="chap5"><p class="chaphead"><span class="chapnum">5.</span>Abschliessende Konfiguration der jollix Festplatteninstallation</p></a>

<p>Nachdem nun jollix auf die Festplatte kopiert wurde, wird ein <span class="shell">chroot</span> durchgef&uuml;hrt, so dass man direkt aus dem neuen jollix System heraus &Auml;nderungen und Konfigurationen durchf&uuml;hren kann. Die folgenden Befehle der Reihe nach durchf&uuml;hren [5.1 bis 5.6]:</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.1: In das Verzeichnis der neuen jollix Festplatteninstallation wechseln, Befehl: cd</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> cloop # </span><span class="whitetext">cd /mnt/jollix</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.2: proc Verzeichnis in die neue jollix Installation einbinden, Befehl: mount</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">mount -t proc proc /mnt/jollix/proc</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.3: Kopieren der Konfigurationsdatei resolv.conf, Befehl: cp</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">cp /etc/resolv.conf /mnt/jollix/etc/resolv.conf</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.4: In die neue jollix Festplatteninstallation wechseln, Befehl: chroot</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">chroot /mnt/jollix /bin/bash</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.5: env-update</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">env-update</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Ausgabe von env-update:</b></p>
<pre>Regenerating /etc/ld.so.cache...
</pre>
</td></tr></table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.6: Profil laden</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">source /etc/profile</span>
</pre></td></tr>
</table>

<p>Nun befindet man sich direkt im neuen jollix System auf der Festplatte. Sollte in den nun folgenden Schritten ein Fehler auftreten oder zu einem sp&auml;teren Zeitpunkt, ist es <b>nicht</b> notwendig alle bereits durchgef&uuml;hren Schritte zu wiederholen, sondern man kann jederzeit wieder bei [5.1] in das neue Festplatten System von der LiveCD aus per chroot wechseln und so Fehler korrigieren. Allerdings m&uuml;ssen die Partitionen zuvor, wie unter [4.1] bis [4.4] erl&auml;utert, gemountet werden.</p>

<p>Im n&auml;chsten Schritt wird der Bootmanager grub installiert und konfiguriert. Dieser wird in den MBR (Masterbootrecord) der Festplatte installiert und bietet die M&ouml;glichkeit, auch andere Betriebssysteme zu booten. Das Installationsprogramm von grub wird direkt in der Konsole aufgerufen. Sobald es gestartet ist, werden 2 Befehle an grub geschickt. Es muss zun&auml;chst festgelegt werden, welche Partition die jollix boot-Partition ist, im ersten Beispiel oben wurde hda1 als boot-Partition vorgesehen. Daher lautet der Befehl <span class="shell">root (hd0,0)</span>. Zur Erl&auml;uterung: hd0 bezeichnet die erste Festplatte am 1. IDE-Kanal, also hda. (hd0,0) steht folglich f&uuml;r die 1. Partition der 1. Festplatte. Grub f&auml;ngt bei 0 mit dem Z&auml;hlen an und nicht bei 1! Befindet sich in der 1. Partition ein anderes System, wie im 2. Beispiel erl&auml;utert wurde, und die jollix boot-Partition demnach in der zweiten Partition der Festplatte (hda2), &auml;ndert sich der Befehl zu <span class="shell">root (hd0,1)</span>. Der zweite Befehl sagt grub, wohin grub installiert werden soll. Der Befehl lautet <span class="shell">setup (hd0)</span> und installiert grub in den MBR der 1. Festplatte. Die Konsolenausschnitte [5.7] und [5.8] zeigen die erl&auml;uterten Schritte f&uuml;r die Einrichtung von grub im MBR der 1. Festplatte:</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.7: Bootmanager grub starten, Befehl: grub</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">grub</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.8: Bootmanager grub installieren</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="whitetext">
grub> root (hd0,0)
grub> setup (hd0)
grub> quit</span>
</pre></td></tr>
</table>

<p>Der Bootmanager grub ist nun installiert und muss im Folgenden nun noch f&uuml;r die verschiedenen Systeme, die wir booten wollen, konfiguriert werden. Dies geschieht in einer Textdatei, der grub.conf, die sich in im Verzeichnis <span class="path">/boot</span> befindet. Die Eintr&auml;ge werden mit einem Texteditor gemacht. Empfohlen wird nano, der sehr leicht zu bedienen ist. Wichtig: Speichern und nano verlassen mit <span class="shell">Strg+x</span>.</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.9: Bootmanager grub konfigurieren, Befehl: nano</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">nano -w /boot/grub/grub.conf</span>
</pre></td></tr>
</table>

<p>Die einfache grub.conf, wie unten abgebildet, kann sofort benutzt werden, sofern wie im 1. Beispiel nur jollix auf der Festplatte installiert wurde. Das zweite Beispiel bezieht sich auf eine Installation mit einem zweiten Betriebssystem in der 1. Partition der Festplatte. Die Nummerierung gleicht der oben beschriebenen, z.B. (hd0,1). Die grub.conf unten (einfache grub.conf) kann unver&auml;ndert so &uuml;bernommen werden, wenn die Partitionierung wie oben im 1. Beispiel gemacht wurde.<br>Hier ist es bei jollix 0.3 auch möglich die Bootparamet der LiveCD der Kernel Zeile hinzuzufügen. Für Besitzer einer Wheelmaus (Maus mit Mausrad) empfiehlt es sich, wheel als zuätzliche Bootoption anzugen. Jollix konfiguriert dann beim ersten Booten die X Konfigurationsdatei /etc/X11/XF86Config-4 mit Wheelmaus Unterstützung. </p>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Einfache grub.conf (jollix 0.3):</b></p>
<pre>default 0
timeout 10
splashimage=(hd0,0)/boot/grub/splash.xpm.gz

title=jollix starten
root (hd0,0)
kernel (hd0,0)/boot/vmlinuz-2.6.5-r1 root=/dev/hda3 splash=silent video=vesa:ywrap,mtrr vga=0x317
initrd=(hd0,0)/boot/initrd-1024x768
</pre>
</td></tr></table>

<p>Zweite, erweiterte grub.conf mit einem anderen System in der 1. Partition und der Einrichtung eines Bootmen&uuml;s zum Ausw&auml;hlen:</p>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Erweiterte grub.conf mit Windows in der 1. Partition (hda1) und der jollix boot Partition in der 2. Partition (hda2):</b></p>
<pre>default 0
timeout 30
splashimage=(hd0,1)/boot/grub/splash.xpm.gz

title=jollix starten
root (hd0,1)
kernel (hd0,1)/boot/vmlinuz-2.6.5-r1 root=/dev/hda4 splash=silent video=vesa:ywrap,mtrr vga=0x317
initrd=(hd0,1)/boot/initrd-1024x768

title=Windows XP
root (hd0,0)
chainloader (hd0,0)+1
</pre>
</td></tr></table>

<p>Im n&auml;chsten Schritt wird die Datei <span class="path">/etc/fstab</span> entsprechend der oben durchgef&uuml;hrten Partitionierung konfiguriert. Wurde das 1. Beispiel mit drei Partitionen &uuml;bernommen, fallen nur sehr wenig &Auml;nderungen an. Man &ouml;ffnet <span class="path">/etc/fstab</span> mit nano und entfernt die Kommentierungen (#) vor den /dev/hda Eintr&auml;gen, so dass die Datei, wie unten gezeigt aussieht. Aus #/dev/hda1 wird /dev/hda1 ohne #. Wurde eine andere Partitionierung vorgenommen mit der jollix boot-Partition in der 2. Partition der Festplatte (hda2), so muss die Datei <span class="path">/etc/fstab</span> entsprechend anpasst werden, boot (hda2), swap (hda3) und root (hda4).</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.10: fstab konfigurieren, Befehl: nano</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">nano -w /etc/fstab</span>
</pre></td></tr>
</table>

<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>Einfache fstab (jollix 0.3):</b></p>
<pre>/dev/hda1		/boot		ext2		noauto,noatime		1 1
/dev/hda3		/		ext3		noatime			0 0
/dev/hda2		none		swap		sw			0 0
/dev/cdroms/cdrom0	/mnt/cdrom0	iso9660		noauto,ro,user,unhide	0 0
/dev/cdroms/cdrom1	/mnt/cdrom1	iso9660		noauto,ro,user,unhide	0 0
/dev/fd0        	/mnt/floppy	vfat		noauto,ro,user,unhide	0 0
none                    /sys            sysfs           defaults                0 0
proc			/proc		proc		defaults		0 0
tmpfs			/dev/shm	tmpfs		defaults		0 0
</pre>
</td></tr></table>

<p>Die jetzt noch folgenden Schritte sind nur noch Restaurierungen der original Konfigurationsdateien, die f&uuml;r das richtige Funktionieren der LiveCD ver&auml;ndert werden mussten [5.11 bis 5.13].</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.11: local wiederherstellen, Befehl: cp</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cp /spare/etc/local-org /etc/init.d/local</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.12: modules wiederherstellen, Befehl: cp</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cp /spare/etc/modules-org /etc/init.d/modules</span>
</pre></td></tr>
</table>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.13: checkroot wiederherstellen, Befehl: cp</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cp /spare/etc/checkroot-org /etc/init.d/checkroot</span>
</pre></td></tr>
</table>

<p>Im Folgenden werden die Gentoo Portage Installationsdatenbank und andere Verzeichnisse wiederhergestellt [5.14].</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.14: Installationsdatenbank wiederherstellen, Befehl: tar</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cd /var</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">tar -xjpf /spare/var-spare.tar.bz2</span>
</pre>
</td></tr>
</table>

<p>Abschliessend noch ein neues root Kennwort vergeben. Dies wird dringend empfohlen!</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
5.15: root Passwort neu setzen, Befehl: passwd</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">passwd</span>
</pre>
</td></tr>
</table>

<p>Jetzt ist jollix 0.3 installiert und kann von der Festplatte gebootet werden, die Schritte werden im Folgenden gezeigt.</p>

<a name="chap6"><p class="chaphead"><span class="chapnum">6.</span>Installation beenden und Rechner neu starten</p></a>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
6.1: Installationsverzeichnis unmounten und Neustart</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">exit</span>
</pre></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">cd /</span>
</pre></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">umount /mnt/jollix/boot</span>
</pre></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">umount /mnt/jollix/proc</span>
</pre></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">umount /mnt/jollix</span>
</pre></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> jollix # </span><span class="whitetext">exit</span>
</pre></td></tr>
</table>

<p>Anschliessend den Rechner neu starten und die neue jollix Festplatteninstallation booten.</p>

<p>Die folgenden Schritte nach dem ersten Booten von jollix durchführen. Sie erfordern den Download der im FTP Verzeichnis<br><a href="ftp://ftp.berlios.de/pub/jollix/spare/" target="_blank"><span class="path">ftp://ftp.berlios.de/pub/jollix/spare/</span></a> enthaltenen Dateien.<br>Das sind: portage-spare.tar.bz2, kernel-spare.tar.bz2 und doc-spare.tar.bz2. Diese drei Dateien im Ordner "Downloads" speichern und die nachfolgenden Befehle als root ausführen. Also Konsole öffnen und wieder als root anmelden:</p>

<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
6.2: Portage, Kernel Archiv und Dokumentation wiederherstellen, Befehl: tar</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="greentext">user@jollix</span><span class="bluetext"> user # </span><span class="whitetext">su -</span>
</pre></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">mv /home/user/Downloads/portage-spare.tar.bz2 /spare/</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">mv /home/user/Downloads/kernel-spare.tar.bz2 /spare/</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">mv /home/user/Downloads/doc-spare.tar.bz2 /spare/</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cd /usr</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">tar -xjpf /spare/portage-spare.tar.bz2</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cd /usr/src</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">tar -xjpf /spare/kernel-spare.tar.bz2</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">cd /usr/share</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">tar -xjpf /spare/doc-spare.tar.bz2</span>
</pre>
</td></tr>
</table>
<p>Abschließend die Portage ebuild Datenbank updaten.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
6.3: Portage updaten, Befehl: emerge rsync</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">emerge rsync</span>
</pre>
</td></tr>
</table>
<p>jollix ist jetzt fertig installiert inkl. aktuellem Portage Tree und den Kernel Quellen und stellt somit ein komplettes Gentoo System zur Verfügung. Weitere Informationen zu Portage gibt es <a href="http://www.gentoo.org/doc/de/portage-manual.xml" target="_blank">hier</a>.</p><br>
<a name="chap7"><p class="chaphead"><span class="chapnum">7.</span>Einstellungen nach der Installation</p></a>
<p>Im 7. Kapitel sollen kurz wichtige Konfigurationsarbeiten am fertig installierten jollix System erläutert und dazu jeweils weiterführende Internetadressen genannt werden. Die nachfolgenden Unterpunkte sind nur ein Anfang. Die Liste soll bei Bedarf weiter ausgebaut werden. Alle folgendenen Schritte werden als Superuser root durchgeführt.</p>
<p class="chaphead2"><span class="chapnum">7.1</span>Netzwerkeinstellungen</p>
<p>Die Netzwerkeinstellungen wurden beim Ausführen der LiveCD nicht dauerhaft gespeichert. Im Anschluss sollen kurz die Konfigurationsschritte für die Netzwerkeinrichtung einer jollix Festplatteninstallation beschrieben werden.<br>
<ul>
<li>1. /etc/conf.d/net öffnen.<br>In dieser Datei werden die IP Adresse des Rechners und des Gateway eingetragen.<br>Folgende Zeilen sind relevant:<br>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>/etc/conf.d/net:</b></p>
<pre>iface_eth0="191.168.0.1 broadcast 192.168.0.255 netmask 255.255.255.0"
gateway="eth0/192.168.0.1"
</pre>
</td></tr></table></li><br>
<li>2. /etc/resolv.conf öffnen.<br>In dieser Datei wird die IP Adresse des DNS Servers eingetragen.<br>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>/etc/resolv.conf:</b></p>
<pre>nameserver 192.168.0.1
</pre>
</td></tr></table></li><br>
<li>3. Modul der Netzwerkkarte (Treiber) in /etc/modules.autoload eintragen.<br>Vorher sollte man wissen, welche Netzwerkkarte sich im Rechner befindet, bzw. mit welchem Chipsatz die Netzwerkkarte ausgestattet ist, Beispiel 3c59x für 3com Karten, ne2kpci für Realtek Karten. Die von jollix automatisch geladenen Module kann man mit dem Befehl lsmod anzeigen lassen. In dieser Liste sollte, sofern die Netzwerkkarte richtig erkannt wurde, auch das Modul für die eigene Karte gelistet sein. Den Modulnamen dann anschließend in die Konfigurationsdatei /etc/modules.autoload eintragen. Das Modul wird nun automatisch beim Booten geladen, so dass im folgenden Schritt, das Netzwerk ebenfalls automatisch beim Booten gestartet werden kann.</li><br>
<li>4. Netzwerk automatisch beim Booten starten:<br>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
Netzwerk automatisch beim Booten starten, Befehl rc-update add</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">rc-update add net.eth0 default</span>
</pre>
</td></tr>
</table>
<p>Mit rc-update und den Optionen add und del werden Dienste, wie das Netzwerk, zum Bootvorgang hinzugefügt bzw. entfernt ("rc-update del net.eth0 default" würde demnach das automatische Starten des Netzwerks abschalten).</p></li><br>
<li>5. Netzwerk ohne Neustart aktivieren:<br>jollix muss nicht neu gestartet werden, um das Netzwerk sofort in Betrieb nehmen zu können. Als root folgenden Befehl in einer Konsole eingeben zum manuellen Starten des Netzwerkes:<br>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
Netzwerk manuell starten</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">/etc/init.d/net.eth0 start</span>
</pre>
</td></tr>
</table><p>Im Verzeichnis /etc/init.d befinden sich die Startskripte zum Starten, Stoppen, Neustarten und Statusabfrage der Dienste [start, stop, restart, status]. Mehr Informationen zu den Diensten sind <a href="http://www.gentoo.org/doc/de/rc-scripts.xml" target="_blank">hier</a> zu finden.</li>
</ul><br>
<p class="chaphead2"><span class="chapnum">7.2</span>Drucken mit jollix, der Druckserver cups</p>
<p>Der Druckserver cups muss vor der Konfiguration eines Druckers als Dienst gestartet werden. Folgender Befehl stellt dies sicher und startet den Druckerserver automatisch beim Booten von jollix</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
Druckerserver cups automatisch starten, Befehl rc-update add</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">rc-update add cupsd default</span>
</pre>
</td></tr>
</table>
<p>Auch hier muss jollix nicht neu gestartet werden, um den Druckerserver sofort zu starten, analog zu [7.1] lautet der Befehl:</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
Druckerserver cups manuell starten</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">/etc/init.d/cupsd start</span>
</pre>
</td></tr>
</table>
<p>Anschließend das KDE Kontrollzentrum öffnen. Unter "Angeschlossene Geräte" "Drucker" auswählen, in den "Systemverwaltungsmodus" wechseln, root Passwort eingeben und als "Aktuelles Drucksystem" CUPS auswählen. Über "Hinzufügen" den Drucker aussuchen und konfigurieren. Mehr zum Thema Drucken findet man <a href="http://www.gentoo.de/inhalte/doku/printing-howto/" target="_blank">hier.</a></p>
<p class="chaphead2"><span class="chapnum">7.3</span>NVidia Grafikkartentreiber installieren</p>
<p>Die Installation der original NVidia Treiber unter Gentoo/jollix ist mit wenigen Befehlen erledigt und von jedem, der die Installation überstanden hat, durchführbar. Es müssen zunächst zwei Pakete installiert werden, zum einen der NVidia Kernel Treiber und zum zweiten die NVidia OpenGL Umgebung.<br>Vorher sollte man noch ein emerge rsync durchführen, sofern man dies nicht bereits beim Abschluss der Installation getan hat, um die Installationsskripte auf den aktuellen Stand zu bringen. Voraussetzung für die folgende Installation ist, dass man als root an einer Konsole angemeldet ist (su-) und eine Internetverbindung besteht.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
NVidia Pakete installieren, Befehl emerge mit Schalter -p</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">emerge -p nvidia-kernel</span>
</pre>
</td></tr>
</table>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>emerge mit Schalter -p</b></p>
<pre>These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] media-video/nvidia-kernel-1.0.4496-r3
</pre>
</td></tr></table>
<p>Hier meldet emerge, dass die Version 1.0.4496-r3 der NVidia Treiber neu installiert werden soll, zu erkennen an [ebuild  N    ]<br>Nachdem
man nun weiss, was emerge installieren wird, kann man den Befehl ohne den Schalter -p wiederholen und die Installation wird ausgeführt.<br>Die von emerge vorgeschlagene Version des NVidia Treibers entspricht sehr wahrscheinlich nicht der aktuellsten von NVidia freigegeben Version. Dies bedeutet allerdings nicht, dass diese nicht unter Gentoo/jollix installierbar ist, sondern die von emerge -p vorgeschlagene Version entspricht vielmehr der von Gentoo momentan als stabil freigegebenen Version.<br>Möchte man die aktuellste (jedoch noch als nicht stabil maskierte) Version der Treiber installieren, so muss man vor dem nächsten Schritt die Umgebungsvariable ACCEPT_KEYWORDS auf "~x86" setzen. Hierbei riskiert man, dass evtl. Fehler und Instabilitäten auftreten, man stellt jedoch sicher, dass die in Portage als letztes verfügbare Version des Treibers installiert wird. Nachdem man die Umgebungsvariable gesetzt hat, bleibt diese bis zum Schließen der Konsole aktiv.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
NVidia Pakete installieren, Befehl emerge</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">export ACCEPT_KEYWORDS="~x86"</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">emerge nvidia-kernel</span>
</pre>
</td></tr>
</table>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre>Calculating dependencies ...done!
>>> emerge (1 of 1) media-video/nvidia-kernel-1.0.4496-r3 to /
*** Adjusting cvs-src permissions for portage user...
>>> Downloading ftp://gentoo.inode.at/source/distfiles/NVIDIA-Linux-x86-1.0-4496-pkg0.run
--22:57:51--  ftp://gentoo.inode.at/source/distfiles/NVIDIA-Linux-x86-1.0-4496-pkg0.run
           => `/usr/portage/distfiles/NVIDIA-Linux-x86-1.0-4496-pkg0.run'
Resolving gentoo.inode.at... 81.223.20.162
Connecting to gentoo.inode.at[81.223.20.162]:21... connected.
Logging in as anonymous ... Logged in!
==> SYST ... done.    ==> PWD ... done.
==> TYPE I ... done.  ==> CWD /source/distfiles ... done.
==> PASV ... done.    ==> RETR NVIDIA-Linux-x86-1.0-4496-pkg0.run ... done.
Length: 5,125,585 (unauthoritative)
</pre>
</td></tr></table>
<p>Hierbei holt emerge automatisch die Installationsdatei aus dem Internet, packt diese aus und führt die Installation im System durch.</p>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre>>>> media-video/nvidia-kernel-1.0.4496-r3 merged.
>>> Recording media-video/nvidia-kernel in "world" favorites file...
</pre>
</td></tr></table>
<p>Als zweites wird die OpenGL Umgebung installiert. Sofern man vorher die Umgebungsvariable auf "~x86" gesetzt hat, sollte man vor dem nächsten Schritt die Konsole nicht schließen, damit die Variable gesetzt bleibt.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
NVidia Pakete installieren, Befehl emerge</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">emerge nvidia-glx</span>
</pre>
</td></tr>
</table>
<p>Die NVidia OpenGL Umgebung für X11 wird während der Installation automatisch aktiviert. Den NVidia Treiber kann man nun probeweise laden und in /etc/modules.autoload.d/kernel-2.6 eintragen, damit er zukünftig automatisch beim Booten geladen wird.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
NVidia Treiber laden, Befehl modprobe</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">modprobe nvidia</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">nano -w /etc/modules.autoload.d/kernel-2.6</span>
</pre>
</td></tr>
</table>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre># /etc/modules.autoload.d/kernel-2.6:  kernel modules to load when system boots.
# $Header: /home/xubuntu/berlios_backup/github/tmp-cvs/jollix/Repository/jollix/public_html/de/de_docu.html,v 1.13 2004/05/07 19:49:13 knochen Exp $
#
# Note that this file is for 2.6 kernels.
#
# Add the names of modules that you'd like to load when the system
# starts into this file, one per line.  Comments begin with # and
# are ignored.  Read man modules.autoload for additional details.

# For example:
# 3c59x
nvidia
</pre>
</td></tr></table>
<p>Die NVidia Treiber sind jetzt vollständig installiert. Möchte man die Treiber und die OpenGL Umgebung direkt ohne Neustart des Rechners aktivieren, muss man nur die Oberfläche neu starten. Befindet man sich im KDE, sollte man sich vorher abmelden und am Anmeldedialog angekommen X neu starten. Dies erreicht man mit der Tastenkombination [Strg]+[Alt]+[Backspace].</p>
<p>Zum Schluss noch einige Worte zur Konfiguartionsdatei xorg.conf:<br>
Die Konfigurationsdatei xorg.conf wird beim ersten Booten von der Festplatte automatisch angelegt, allerdings nur einmal. Besteht diese Datei bereits (nämlich ab dem 2. Booten), erkennt das die Autokonfiguration, so dass die vorhandene Datei nicht überschrieben wird und so die Einstellungen verloren gehen. Die Datei wird demnach nach dem ersten Booten von der Festplatte dynamisch erzeugt und kann dann auch zusätzlich bearbeitet werden. Tritt ein Fehler bei der Bearbeitung auf und die grafische Oberfläche lässt sich im Anschluss nicht mehr starten, kann die xorg.conf auch gelöscht bzw. umbenannt werden und jollix legt die Datei beim nächsten Booten wieder neu an mit den original Einstellungen. Man kann die Datei auch von Hand neu generieren, nachdem man sie gelöscht hat, mit dem Skript <span class="shell">mkxorgconf.sh</span> (als root). Dieses Skript wird auch beim Booten aufgerufen und erstellt dann die neue xorg.conf.</p>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre>jollix # mkxorgconf.sh
 Video is nVidia Corporation|NV5M64 [RIVA TNT2 Model 64/Model 64 Pro], using XOrg-X11(nv) Server
 Monitor is Generic Monitor, H:28.0-96.0kHz, V:50.0-75.0Hz
 Using Modes "1024x768" "800x600" "640x480"
</pre>
</td></tr></table>
<p>Hat man bereits die original NVidia Treiber installiert, so wie oben beschrieben, dann aber die xorg.conf nachträglich selbst editiert und wegen eines Fehlers gelöscht und wieder neu angelegt mit mkxorgconf.sh, fehlen die NVidia spezifischen Angaben. Diese kann man auf einfache Weise durch den Aufruf von <span class="shell">opengl-update nvidia</span> auch noch nachträglich wieder setzen lassen, die Treiber müssen <b>nicht</b> wieder von neu installiert werden. Weiterhin noch zu erwähnen ist die NVidia Option "NVAGP" die von jollix automatisch auf "2" in der xorg.conf gesetzt wird. Mit dem Wert "2" wird festgelegt, dass der langsamere aber stabilere AGP Treiber des Linux Kernels und nicht der schnellere aber absturzgefährdete NVidia Linux AGP Treiber benutzt werden soll. Informationen zum momentan verwendeten AGP Treiber findet man mit cat /proc/driver/nvidia/agp/status<br>Informationen zum NVidia Treiber und OpenGL liefert das Programm <span class="shell">glxinfo</span> (von Interesse ist die Zeile: direct rendering: Yes), das Programm <span class="shell">xvinfo</span> gibt Auskunft über die Video Extensions und  <span class="shell">glxgears</span> startet eine kleine OpenGL 3D Animation, die aber auch ohne OpenGL Unterstützung des Grafikkartentreibers funktioniert, dann allerdings viel langsamer läuft wegen der fehlenden Hardwareunterstützung.</p>

<p class="chaphead2"><span class="chapnum">7.4</span>ATI Grafikkartentreiber installieren</p>
<p>Die Installation der original ATI Treiber unter Gentoo/jollix ist schnell und einfach durchgeführt. Es muss nur ein Paket installiert werden, das den original ATI Kernel Treiber und die ATI OpenGL Umgebung enthält.<br>Vorher sollte man noch ein emerge rsync durchführen, sofern man dies nicht bereits beim Abschluss der Installation getan hat, um die Installationsskripte auf den aktuellen Stand zu bringen. Voraussetzung für die folgende Installation ist, dass man als root an einer Konsole angemeldet ist (su-) und eine Internetverbindung besteht.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
ATI Treiber installieren, Befehl emerge mit Schalter -p</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">emerge -p ati-drivers</span>
</pre>
</td></tr>
</table>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b>emerge mit Schalter -p</b></p>
<pre>These are the packages that I would merge, in order:

Calculating dependencies ...done!
[ebuild  N    ] media-video/ati-drivers-3.2.8-r1
</pre>
</td></tr></table>
<p>Hier meldet emerge, dass die Version 3.2.8-r1 der ATI Treiber neu installiert werden soll, zu erkennen an [ebuild  N    ]<br>Wiederholt man emerge ohne den Schalter -p, wird die Installation durchgeführt.<br>Die von emerge vorgeschlagene Version des ATI Treibers entspricht sehr wahrscheinlich nicht der aktuellsten von ATI freigegeben Version. Dies bedeutet allerdings nicht, dass diese nicht unter Gentoo/jollix installierbar ist, sondern die von emerge -p vorgeschlagene Version entspricht vielmehr der von Gentoo momentan als stabil freigegebenen Version.<br>Möchte man die aktuellste (jedoch noch als nicht stabil maskierte) Version der Treiber installieren, so muss man vor dem nächsten Schritt die Umgebungsvariable ACCEPT_KEYWORDS auf "~x86" setzen. Hierbei riskiert man, dass evtl. Fehler und Instabilitäten auftreten, man stellt jedoch sicher, dass die in Portage als letztes verfügbare Version des Treibers installiert wird. Nachdem man die Umgebungsvariable gesetzt hat, bleibt diese bis zum Schließen der Konsole aktiv.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
ATI Treiber installieren, Befehl emerge</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">export ACCEPT_KEYWORDS="~x86"</span>
</pre>
</td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">emerge ati-drivers</span>
</pre>
</td></tr>
</table>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre>Calculating dependencies ...done!
>>> emerge (1 of 1) media-video/ati-drivers-3.7.6-r1 to /
>>> Downloading ftp://gentoo.inode.at/source/distfiles/fglrx-4.3.0-3.7.6.i386.rpm
--14:44:09--  ftp://gentoo.inode.at/source/distfiles/fglrx-4.3.0-3.7.6.i386.rpm
           => `/usr/portage/distfiles/fglrx-4.3.0-3.7.6.i386.rpm'
Resolving gentoo.inode.at... 81.223.20.162
Connecting to gentoo.inode.at[81.223.20.162]:21... connected.
Logging in as anonymous ... Logged in!
==> SYST ... done.    ==> PWD ... done.
==> TYPE I ... done.  ==> CWD /source/distfiles ... done.
==> PASV ... done.    ==> RETR fglrx-4.3.0-3.7.6.i386.rpm ... done.
Length: 3,380,217 (unauthoritative)
</pre>
</td></tr></table>
<p>Hierbei holt emerge automatisch die Installationsdatei aus dem Internet, packt diese aus und führt die Installation im System durch.</p>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre>>>> media-video/ati-drivers-3.7.6-r1 merged.
>>> Recording media-video/ati-drivers in "world" favorites file...
</pre>
</td></tr></table>
<p>Nun muss noch die ATI OpenGL Umgebung aktiviert werden.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
ATI OpenGL aktivieren, Befehl opengl-update</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">opengl-update ati</span>
</pre>
</td></tr>
</table>
<p>Die ATI OpenGL Umgebung für X11 wurde nun aktiviert. Der zuvor geladene Kernel Radeon Treiber muss vor der Aktivierung des original ATI Treibers fglrx noch deaktiviert werden.</p>
<table class="ntable" width="100%" cellspacing="0" cellpadding="0" border="0">
<tr><td class="infohead" bgcolor="#eec625"><p>
Kernel  radeon Modul deaktivieren, Befehl rmmod</p></td></tr>
<tr><td bgcolor="#000000"><pre>
<span class="redtext">jollix</span><span class="bluetext"> / # </span><span class="whitetext">rmmod radeon</span>
</pre>
</td></tr>
</table>
<p>Die ATI Treiber sind jetzt vollständig installiert. Möchte man die Treiber und die OpenGL Umgebung direkt ohne Neustart des Rechners aktivieren, muss nur noch die Oberfläche neu gestartet werden. Befindet man sich im KDE, sollte man sich vorher abmelden und am Anmeldedialog angekommen X neu starten. Dies erreicht man mit der Tastenkombination [Strg]+[Alt]+[Backspace].</p>
<p>Zum Schluss noch einige Worte zur Konfiguartionsdatei xorg.conf:<br>
Die Konfigurationsdatei xorg.conf wird beim ersten Booten von der Festplatte automatisch angelegt, allerdings nur einmal. Besteht diese Datei bereits (nämlich ab dem 2. Booten), erkennt das die Autokonfiguration, so dass die vorhandene Datei nicht neu überschrieben wird und so die Einstellungen verloren gehen. Die Datei wird demnach nach dem ersten Booten von der Festplatte dynamisch erzeugt und kann dann auch zusätzlich bearbeitet werden. Tritt ein Fehler bei der Bearbeitung auf und die grafische Oberfläche lässt sich im Anschluss nicht mehr starten, kann die xorg.conf auch gelöscht bzw. umbenannt werden und jollix legt die Datei beim nächsten Booten wieder neu an mit den original Einstellungen. Man kann die Datei auch von Hand neu generieren, nachdem man sie gelöscht hat, mit dem Skript <span class="shell">mkxorgconf.sh</span> (als root). Dieses Skript wird auch beim Booten aufgerufen und erstellt dann die neue xorg.conf.</p>
<table class="ncontent" width="100%" border="0" cellspacing="0" cellpadding="0"><tr><td bgcolor="#dbdbdb">
<p class="note"><b></b></p>
<pre>jollix / # mkxorgconf.sh
 Video is ATI|Radeon R200 QL [Radeon 8500 LE], using XOrg-X11(radeon) Server
 Monitor is Generic Monitor, H:28.0-96.0kHz, V:50.0-75.0Hz
 Using Modes "1024x768" "800x600" "640x480"
</pre>
</td></tr></table>
<p>Hat man bereits die original ATI Treiber installiert, so wie oben beschrieben, dann aber die xorg.conf nachträglich selbst editiert und wegen eines Fehlers gelöscht und wieder neu angelegt mit mkxorgconf.sh, dann fehlen die ATI spezifischen Angaben. Diese kann man auf einfache Weise durch den Aufruf von <span class="shell">opengl-update ati</span> auch noch nachträglich wieder setzen lassen, die Treiber müssen <b>nicht</b> wieder neu installiert werden. Experten können auch das ATI Konfigurationstool <span class="shell">fglrxconfig</span> benutzen, um eine auf die eigene ATI Karte und Bildschirm speziell angepasste Konfigurationsdatei zu generieren (zu finden unter /opt/ati/bin).<br>Informationen zum ATI Treiber und OpenGL liefert das Programm <span class="shell">glxinfo</span> (von Interesse ist die Zeile: direct rendering: Yes) sowie das Programm <span class="shell"> /opt/ati/bin/fglrxinfo</span>, das Programm <span class="shell">xvinfo</span> gibt Auskunft über die Video Extensions und <span class="shell">glxgears</span> startet eine kleine OpenGL 3D Animation, die aber auch ohne OpenGL Unterstützung des Grafikkartentreibers funktioniert, dann allerdings viel langsamer läuft wegen der fehlenden Hardwareunterstützung.</p>


</td>
</tr>
</table>
</div>
</body>

</html>
